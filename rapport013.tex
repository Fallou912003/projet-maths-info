%! TEX program = xelatex
\documentclass[a4paper]{article}
\usepackage{amsmath, amssymb, mathtools}
\usepackage{amsthm}
\usepackage{fontspec}
\usepackage{xunicode}
\usepackage{fancyhdr}
\usepackage[french]{babel}
\usepackage[a4paper,centering]{geometry}
\usepackage{algorithm, algorithmic}
\usepackage{listings}
\usepackage{color}
\usepackage{graphicx}
\usepackage{enumitem}

\fancyhead[L, C, R]{}
\fancyfoot[L, R]{}
\fancyfoot[C]{\vspace{1mm}\thepage}
\renewcommand{\headrulewidth}{1pt}
\renewcommand{\footrulewidth}{1pt}
\pagestyle{fancy}

\definecolor{gray}{rgb}{0.94, 0.94, 0.94}
\definecolor{red}{rgb}{0.6, 0, 0}

\lstset{
    numbers=left,
    numberstyle=\tiny, 
    backgroundcolor=\color{gray},
    language=Python,
    keywordstyle=\color{red},
    breaklines=true,
    frame=leftline,
    tabsize=4,
}

\begin{document}

\thispagestyle{plain}

\begin{titlepage}
    \begin{center}

        \bigskip
        \includegraphics[scale=0.5]{logo_su.jpg}~\\[4cm]

        {\LARGE Rapport du projet LU2IN013}\\[0.3cm]
        \rule{\linewidth}{0.5mm} \\[0.6cm]
        {\huge \textbf{Composition modulaire des polynômes à une variable}}\\[0.4cm]
        \rule{\linewidth}{0.5mm} \\[1cm]
        {\large Encadrant : M. Vincent NEIGER}\\[5cm]

        {\Large Serigne Fallou FALL, Marie BONBOIRE}
        
        \vfill
        Février 2023 - Juin 2023


    \end{center}
\end{titlepage}

\newpage

\tableofcontents

\newpage


\section{INTRODUCTION}
\subsection{Sujet}
\subsection{Objectifs}
\subsection{Choix d'implantation}


\section{NOTIONS ET NOTATIONS}


\subsection{Arithmétique modulaire}

\begin{itemize}[label=$\star$]
 \item Corps d'étude : ${\mathbb{Z}/p \mathbb{Z}}$
Notre étude porte principalement sur les opérations des polynomes dans l'anneau $Z/pZ$ , où p est un nombre premier, on travaille avec des polynômes à coefficients modulo p. Cela présente plusieurs avantages comme :
	\begin{itemize}

  		\item réduction des calculs à des opérations arithmétiques plus simples sur des entiers avec le modulo p.
  		\item simplification et limitations de la taille des coefficients pour obtenir des résultats plus facilement et permet d'exploiter des propriétés spécifiques de l'arithmétique modulaire.
  
	\end{itemize}
	
 \item Division euclidienne

\end{itemize}

\section{Multiplication}

Dans cette section, on étudie deux algorithmes qui calculent le produit de deux polynômes univariés.
Comprendre comment améliorer les performances d'un algorithme et les manipulations possibles sur les polynômes.


Soient deux polynômes $f$,g $\in \mathbb{Z}/p\mathbb{Z}[\mathrm{X}]$ de degré strictement inférieur à $n$ :
\[
f=f_0+f_1\mathrm{X}+...+f_{n-1}\mathrm{X}^{n-1}\text{ et g}=\mathrm{g}_0+\mathrm{g}_1\mathrm{X}+...+\mathrm{g}_{n-1}\mathrm{X}^{n-1}
\]

\subsection{Algorithme naif}

Ce premier algorithme consiste à simplement développer le produit des coefficients :
\[
f\text{g}=\sum_{i=0}^{2n-2} (\sum_{j+k=i}f_j\mathrm{g}_k) \mathrm{X}^i
\]
Cet algorithme est donc en $O(n^2)$. Pour multiplier deux polynômes de degrés \textit{m} et \textit{n}, l'algorithme naïf demande au plus (\textit{m}+1)\textsf{x}(\textit{n}+1) multiplications dans $\mathbb{A}$ et
\textit{mn} additions dans $\mathbb{A}$

\begin{lstlisting}[title={multiplication naive}]
    def mult_naive(f, g) :
    ring = f.parent()

    #initialisation de la liste des coefficients
    res = [0]*(f.degree()+g.degree()+1) 
    
    for i in range(0, f.degree()+1):
        for j in range(0, g.degree()+1):
            res[i+j] += f[i]*g[j]

    return ring(res) 
\end{lstlisting}


\subsection{Algorithme de Karatsuba}

L'amélioration proposée par Karatsuba repose sur le fait de scinder les polynomes selon :
\[
f=f^{(0)}+f^{(1)}\mathrm{X}^k\text{ et }\mathrm{g} = \mathrm{g}^{(0)}+\mathrm{g}^{(1)}\mathrm{X}^k
\]
avec $f^{(0)}, f^{(1)}, \mathrm{g}^{(0)}, \mathrm{g}^{(1)}$ de degrés au plus k-1, k=$\lceil n/2 \rceil$. Le produit s'écrit alors :
\[
fg = f^{(0)}g^{(0)}+(f^{(0)}g^{(1)}+f^{(1)}g^{(0)})\mathrm{X}^k+f^{(1)}g^{(1)}\mathrm{X}^{2k} 
\]
Les opérations associées à l'algorithme permettent de gagner une multiplication par rapport à l'algorithme naïf. Par le biais des appels récursifs, ce gain se retrouve dans la puissance de l'exposant.
Ainsi, l'algorithme de Karatsuba est en $O(n^{log_2(3)}) = O(n^{1,59})$

\[
  fg = f^{(0)}g^{(0)}
  +\left((f^{(0)}+f^{(1)}) (g^{(0)} + g^{(1)}) - f^{(0)}g^{(0)} - f^{(1)}g^{(1)}\right)\mathrm{X}^k+
  f^{(1)}g^{(1)}\mathrm{X}^{2k} 
\]


\begin{lstlisting}[title={karatsuba}]
def karatsuba(f, g) :
    ring = f.parent()

    #cas de base
    if f.is_zero() : return f
    if g.is_zero() : return g
    
    #seuil à partir duquel la multiplication naïve est plus performante
    if (f.degree() <= 10 and g.degree() <= 10) : 
        return mult_naive(f, g)

    k = max(f.degree()/2, g.degree()/2).ceil()

    #extraction des sous polynômes
    f0 = ring(f.list()[:k]); f1 = ring(f.list()[k:])
    g0 = ring(g.list()[:k]); g1 = ring(g.list()[k:])

    #opérations de l'algorithme
    h1 = karatsuba(f0, g0)
    h2 = karatsuba(f1, g1)
    h5 = karatsuba(f0+f1, g0+g1)
    h7 = h5 - h1 - h2

    h = h1 + h7.shift(k) + h2.shift(2*k)

    return h
\end{lstlisting}


\subsection{Comparaison performances}

\cite{aecf} Ces algorithmes sont complémentaires et non en compétition. En effet, pour des polynomes de degré inférieurs à 20 (?????) , on préfèrera l'algorithme naïfs.

Performances : insérer tableau de comparaison  (seuil = ??????)

\section{ALGORITHMES DE COMPOSITION MODULAIRE}

 Dans cette autre section du rapport, on s'intéresse à l'étude et la comparaison de trois algorithmes de composition modulaire qui calculent g(a) mod f avec $f$,g $\in \mathbb{Z}/p\mathbb{Z}[\mathrm{X}]$ de degré $n$ et a de degré $n$
 
\subsection{Algorithme naïf}

\begin{lstlisting}[title={naive}]
def eval_naive(g, a, f) :
	ring = g.parent()

	res = ring(g[0])
	ai = a % f
	for i in range(1, g.degree()+1) :
		res = res + g[i]*ai
		ai = (a*ai) % f
	return res % f
\end{lstlisting}

\subsection{Algorithme d'Horner}

\[
f(x)=f_0+f_1x+...+f_{n-1}x^{n-1}= (...((f_{n-1}x+f_{n-2})x+f_{n-3})...)x+f_0    
\]

\begin{lstlisting}[title={Horner}]
def horner(g, a, f) :
    res = g[g.degree()]
    for i in range(g.degree()-1, -1, -1) :
        res = (res*a)%f + g[i]
    return res%f
\end{lstlisting}

\subsection{Algorithme de Brent et Kung}

Étant donnés $\text{f}\in\mathbb{K}[\mathrm{X}]$ de degré n, a dans $\mathbb{K}[\mathrm{X}]_{<n}$ et \text{g} dans $\mathbb{K}[\mathrm{Y}]_{<n}$, l'algorithme de \text{Brent et Kung} calcule \text{g(a)}  mod \text{f} avec une complexité en \text{\~O}$((1+\text{n/d})d^{\omega_{2}/2})$. $\omega$ représente le plus petit nombre réel tels que deux matrices $\textit{n}\times\textit{n}$ peuvent être multipliées en $O(\textit{n}^{\omega+\epsilon})$ opérations pour tout $\epsilon>0$. 

L'algorithme de \text{Brent et Kung} met en avant l'impact de la multiplication de matrices rectangulaires et à quel point la vitesse d'exécution dépend du degré de \text{f et de g}. Il peut etre vu comme une introduction à  l'algorithme de \text{Nusken-Ziegler} qui généralise cette approche à un polynome \text{g} à deux variables.

\begin{lstlisting}[title={brent and kung}]
def brentkung(g, a, f) :

	ring = a.parent()
	d = g.degree()+1; n = f.degree()
	if a.degree() >= n:
		raise ValueError("Erreur: a de degré trop élevé")

	r = RR(d.sqrt()).ceil()
	s = RR(d/r).ceil()

    #calcul des puissances de a
	ac = [ring(0)]*(r+1)
	ac[0] = ring(1)
	for i in range(1, r+1) :
		ac[i] = (a*ac[i-1]) % f

    #calcul du produit matriciel
	ma = matrix(r, n, [(ac[i])[j] for i in range(r) for j in range(n)])
	mg = matrix(s, r, [g[i*r+j] for i in range(s) for j in range(r)])
	mb = mg*ma

    #liste coefficients -> polynôme
	b = [ring(0)]*s
	for i in range(s) :
		b[i] = ring(mb[i].list())

	res = b[0]
	ar = ac[r]

	res = horner(b, ar, f)
	return res
\end{lstlisting}

\subsection{Comparaison}


\section{ALGORITHME DE NUSKEN ET ZIEGLER}

\begin{lstlisting}[title={nusken et ziegler}]

def nusken(g, a, f) :
    ring = a.parent()
    d = RR(sqrt(g.degree()+1)).ceil()

    #réécriture
    ringY = g.parent().univariate_ring(y)
    lg = ringY(g)

    #calcul du produit matriciel
    mg = matrix(d, d, [lg[i+d*j](X) for j in range(d) for i in range(d) ])

    ac = [ring(0)]*d
    ac[0] = ring(1)
    for i in range(1, d) :
        ac[i] = (a*ac[i-1]) % f

    ma = vector(ac)
    
    mr = mg*ma

    r = [ring(0)]*d
    for j in range(d) :
        r[j] = ring(mr[j].list()) %f
    
    #calcul des autres puissances de a
    aj = [ring(0)]*d
    for j in range(d) :
        aj[j] = a**(d*j) %f

    #calcul du resultat
    res = ring(0)
    for j in range(d) :
        res += r[j]*aj[j] %f

    return res

\end{lstlisting}

\newpage
\section{BIBLIOGRAPHIE}

\bibliographystyle{plain}
\bibliography{biblio}

\begin{thebibliography}{10}
    \bibitem{aecf} Alin Bostan, Frédéric Chyzak, Marc Giusti, Romain Lebreton, Grégoire Lecerf, Bruno Salvy, Eric Schost,
    \emph{Algorithmes efficaces en calcul formel}, 2017

\end{thebibliography}


\end{document}


